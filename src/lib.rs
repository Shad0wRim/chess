#![warn(missing_docs)]
//! crate docs
mod board;
mod parser;
mod pieces;
mod turn;
mod utils;

pub use board::{ChessBoard, DrawType, GameState, TurnError, Win, WinType};
pub use parser::parse_move;
pub use turn::Turn;

use std::io;
use utils::{print_all_errors, Counter};

use std::error::Error;

#[derive(Debug)]
/// Structure that holds the chess board, game history, and configuration data
pub struct ChessGame {
    board: ChessBoard,
    /// The current game state [GameState]
    pub game_state: GameState,
    position_counter: Counter<String>,
    game_hist: Vec<Turn>,
    /// Sets the perspective that the game is played from, White, Black, or switching between them
    pub rotate_board: RotateBoard,
    /// Sets whether move undos are allowed
    pub allow_undo: bool,
    /// The names of the players playing
    pub players: (String, String),
    /// Sets whether or not the check `+`, capture `x`, and checkmate `#` flags must be specified or
    /// will be autogenerated for the user input
    pub enforce_flags: bool,
}

impl ChessGame {
    /// associated function to make a builder for configuration data
    pub fn builder() -> ChessGameBuilder {
        ChessGameBuilder::default()
    }
    /// generates a fen string for the current board state
    pub fn gen_fen(&self) -> String {
        self.board.gen_fen()
    }
    /// generates a pgn string for the current game history
    pub fn gen_pgn(&self) -> String {
        let mut contents = String::new();
        let result = match self.board.check_gamestate(&self.position_counter) {
            GameState::Continue | GameState::Stop => "*",
            GameState::Win(Win { is_white: true, .. }) => "1-0",
            GameState::Win(Win {
                is_white: false, ..
            }) => "0-1",
            GameState::Draw(_) => "1/2-1/2",
        };
        let mut test_board = ChessBoard::default();
        for (turn_num, moves) in self.game_hist.chunks(2).enumerate() {
            contents.push_str(&format!("{}. ", turn_num + 1));
            for r#move in moves {
                let minimum_move = test_board.get_minimum_move(r#move);
                test_board.update_board(r#move);
                contents.push_str(&minimum_move.to_string());
                contents.push(' ');
            }
            if turn_num % 10 == 9 {
                contents.push('\n');
            }
        }
        contents.push_str(result);
        contents
    }
    /// resets the state of the board, without resetting the configuration
    pub fn reset(&mut self) {
        *self = Self {
            board: ChessBoard::default(),
            game_state: GameState::default(),
            position_counter: Counter::default(),
            game_hist: Vec::default(),
            rotate_board: self.rotate_board,
            allow_undo: self.allow_undo,
            players: self.players.clone(),
            enforce_flags: self.enforce_flags,
        }
    }
    /// Displays the ending message describing the type of win, prints nothing if the game is ongoing
    pub fn display_end_message(&self) {
        match self.game_state {
            GameState::Win(win) => {
                match win.is_white {
                    true => print!("{} wins by ", self.players.0),
                    false => print!("{} wins by ", self.players.1),
                }
                match win.kind {
                    WinType::Checkmate => println!("checkmate"),
                    WinType::Resign => println!("resignation"),
                    WinType::Timeout => println!("timeout"),
                }
            }
            GameState::Draw(draw) => {
                print!("The game is a draw by ");
                match draw {
                    DrawType::Stalemate => println!("stalemate"),
                    DrawType::FiftyMove => println!("the fifty move rule"),
                    DrawType::ThreefoldRepitition => println!("threefold repitition"),
                    DrawType::InsufficientMaterial => println!("insufficient material"),
                    DrawType::Offer => println!("draw offer"),
                }
            }
            GameState::Stop => println!("The game was aborted"),
            GameState::Continue => (),
        };
    }
    /// Makes a move based on the inputted [Turn]
    ///
    /// # Side effects
    ///
    /// On success, updates the contained [ChessBoard], game_hist, game position_counter, and
    /// gamestate
    ///
    /// # Errors
    ///
    /// Returns an error if a move is not a legal chess move. If the enforce flags field is true,
    /// then will also return an error if the flags are incorrect
    pub fn make_move(&mut self, turn: &Turn) -> Result<(), TurnError> {
        let full_turn = self.board.validate_and_complete_turn(*turn)?;
        if let Turn::Move(r#move) = full_turn {
            let Some(board::Source::Square(_)) = r#move.src else {
                panic!("Invalid output from validate_and_complete_turn");
            };
        }
        let full_turn = if self.enforce_flags {
            self.board.enforce_flags(&full_turn)?;
            full_turn
        } else {
            self.board.gen_flags(full_turn)
        };
        let trimmed_fen = self
            .board
            .gen_fen()
            .split_whitespace()
            .take(4)
            .collect::<Vec<_>>()
            .join(" ");
        self.position_counter.add(trimmed_fen);
        self.board.update_board(&full_turn);
        self.game_hist.push(full_turn);

        self.game_state = self.board.check_gamestate(&self.position_counter);
        Ok(())
    }
    /// Undoes the last move if the allow_undo flag is set
    ///
    /// # Side effects
    ///
    /// On success, reverts the state to the exact state before the last move was made
    ///
    /// # Errors
    ///
    /// Returns an error if the allow_undo flag is false
    pub fn undo_move(&mut self) -> Result<(), ()> {
        if !self.allow_undo {
            return Err(());
        }
        self.game_hist.pop();
        let history = self.game_hist.clone();

        self.game_hist = Vec::new();
        self.position_counter = Counter::new();
        self.board = ChessBoard::default();
        for turn in history {
            self.make_move(&turn).unwrap();
        }
        Ok(())
    }
    /// Displays the current state of the board, depending on the perspective set in rotate_board
    pub fn display(&self) {
        // const ED2: &str = "\x1b[2J";
        const ED0: &str = "\x1b[J";
        const CUP: &str = "\x1b[H";
        let buf = match self.rotate_board {
            RotateBoard::White => format!("{}", self.board),
            RotateBoard::Black => format!("{:#}", self.board),
            RotateBoard::Rotate if self.board.is_white() => format!("{}", self.board),
            RotateBoard::Rotate => format!("{:#}", self.board),
        };
        // print!("{}", ED2);
        print!("{}", CUP);
        print!("{}", ED0);
        print!("{}", buf);
        let curr_player = if self.board.is_white() {
            &self.players.0
        } else {
            &self.players.1
        };
        println!("{}'s turn", curr_player);
    }
}

#[derive(PartialEq, Debug, Clone, Copy)]
/// Enum that specifies the orientation of the board when displayed
pub enum RotateBoard {
    /// White prints the board with `a1` in the bottom left
    White,
    /// Black prints the board with `h8` in the bottom left
    Black,
    /// Rotate prints the board with `a1` or `h8` depending on whose turn it is
    Rotate,
}

impl Default for ChessGame {
    fn default() -> Self {
        ChessGame {
            board: ChessBoard::default(),
            game_state: GameState::default(),
            position_counter: Counter::new(),
            game_hist: Vec::default(),
            rotate_board: RotateBoard::White,
            allow_undo: false,
            players: ("White".to_string(), "Black".to_string()),
            enforce_flags: true,
        }
    }
}

/// plays a full game of chess on a local machine, swapping between players
pub fn play_game(game: &mut ChessGame) {
    game.display();
    if game.game_state != GameState::Continue {
        game.display_end_message();
        return;
    }

    let mut buf = String::new();
    loop {
        let outcome: Result<GameState, Box<dyn Error>> = (|| {
            buf.clear();
            io::stdin().read_line(&mut buf)?;

            match buf.to_lowercase().trim() {
                "u" => {
                    if let Ok(_) = game.undo_move() {
                        return Ok(GameState::Continue);
                    } else {
                        return Err("Undoing moves is not allowed".into());
                    }
                }
                "q" => return Ok(GameState::Stop),
                "resign" => {
                    return Ok(GameState::Win(Win {
                        is_white: !game.board.is_white(),
                        kind: WinType::Resign,
                    }))
                }
                "draw" => {
                    println!("Accept draw offer? (y/n)");
                    loop {
                        buf.clear();
                        io::stdin().read_line(&mut buf)?;
                        if buf.to_lowercase().trim() == "y" {
                            return Ok(GameState::Draw(DrawType::Offer));
                        } else if buf.to_lowercase().trim() == "n" {
                            return Ok(GameState::Continue);
                        } else {
                            println!("Enter `y` or `n`");
                            continue;
                        }
                    }
                }
                _ => (),
            }

            let turn = parse_move(buf.trim())?;
            game.make_move(&turn)?;
            Ok(GameState::Continue)
        })();
        match outcome {
            Ok(state) => match state {
                end @ (GameState::Win(_) | GameState::Draw(_)) => game.game_state = end,
                GameState::Stop => {
                    println!("Aborting game");
                    return;
                }
                GameState::Continue => (),
            },
            Err(e) => {
                print_all_errors(e.as_ref());
                continue;
            }
        }

        game.display();

        if game.game_state == GameState::Continue {
            continue;
        } else {
            game.display_end_message();
            return;
        }
    }
}

/// plays a game of chess from a pgn string, progressing when \[Enter\] is pressed
pub fn play_from_pgn(game: &mut ChessGame, file_string: String) {
    let mut buf = String::new();
    let scan_between = |open_delimiter: char, close_delimiter: char, keep: bool| {
        move |is_between: &mut bool, ch: char| {
            if open_delimiter == close_delimiter && ch == open_delimiter {
                *is_between = !*is_between;
                Some('�')
            } else if ch == open_delimiter {
                *is_between = true;
                Some('�')
            } else if ch == close_delimiter {
                *is_between = false;
                Some('�')
            } else if *is_between {
                if keep {
                    Some(ch)
                } else {
                    Some('�')
                }
            } else if keep {
                Some('�')
            } else {
                Some(ch)
            }
        }
    };
    let extract_field = |field: &str| {
        Some(
            file_string
                .split_terminator('\n')
                .find(|line| line.contains(field))?
                .chars()
                .scan(false, scan_between('"', '"', true))
                .filter(|&ch| ch != '�')
                .collect::<String>(),
        )
    };
    if let Some(white_name) = extract_field("White") {
        game.players.0 = white_name;
    }
    if let Some(black_name) = extract_field("Black") {
        game.players.1 = black_name;
    }

    let moves: Vec<_> = file_string
        .split_terminator('\n')
        .skip_while(|line| line.starts_with('[') || line.is_empty())
        .collect::<Vec<_>>()
        .join(" ")
        .chars()
        .scan(false, scan_between('{', '}', false))
        .filter(|&ch| ch != '�')
        .collect::<String>()
        .split_whitespace()
        .map(|substr| {
            substr
                .split('.')
                .last()
                .expect("split always produces an iterator")
        })
        .filter_map(|turn| turn.parse::<Turn>().ok())
        .collect();

    game.display();

    let pgn_read_result = (|| -> Result<GameState, Box<dyn Error>> {
        for r#move in moves {
            io::stdin().read_line(&mut buf)?;
            game.make_move(&r#move)?;
            game.display();
        }

        let game_result = match extract_field("Result") {
            Some(result) => result,
            None => file_string
                .split_whitespace()
                .last()
                .ok_or("Empty file")?
                .to_string(),
        };

        match game_result.as_str() {
            "1/2-1/2" => Ok(GameState::Draw(DrawType::Offer)),
            "1-0" => Ok(GameState::Win(Win {
                is_white: true,
                kind: WinType::Resign,
            })),
            "0-1" => Ok(GameState::Win(Win {
                is_white: false,
                kind: WinType::Resign,
            })),
            "*" => Ok(GameState::Continue),
            _ => Err("Did not find a result for the game".into()),
        }
    })();

    match pgn_read_result {
        Ok(game_result) => match game.game_state {
            GameState::Continue => match game_result {
                GameState::Continue => play_game(game),
                _ => {
                    game.game_state = game_result;
                    game.display_end_message();
                }
            },
            _ => game.display_end_message(),
        },
        Err(e) => {
            print_all_errors(e.as_ref());
        }
    }
}

/// builder struct for setting configuration on a ChessGame
pub struct ChessGameBuilder {
    rotate_board: RotateBoard,
    allow_undo: bool,
    players: (String, String),
    enforce_flags: bool,
}
impl Default for ChessGameBuilder {
    fn default() -> Self {
        ChessGameBuilder {
            rotate_board: RotateBoard::White,
            allow_undo: false,
            players: (String::from("White"), String::from("Black")),
            enforce_flags: true,
        }
    }
}
impl ChessGameBuilder {
    /// initializes a ChessGameBuilder
    pub fn new() -> Self {
        Self::default()
    }
    /// Sets the rotate_board field with the given [RotateBoard] input
    ///
    /// # Default
    ///
    /// [RotateBoard::White]
    pub fn rotate_board(&mut self, val: RotateBoard) -> &mut Self {
        self.rotate_board = val;
        self
    }
    /// Sets the allow_undo flag
    ///
    /// # Default
    ///
    /// `false`
    pub fn allow_undo(&mut self, val: bool) -> &mut Self {
        self.allow_undo = val;
        self
    }
    /// Sets the player names, white first, then black
    ///
    /// # Default
    ///
    /// ("White", "Black")
    pub fn players(&mut self, names: (String, String)) -> &mut Self {
        self.players = names;
        self
    }
    /// Sets the enforce_flags field
    ///
    /// # Default
    ///
    /// `true`
    pub fn enforce_flags(&mut self, val: bool) -> &mut Self {
        self.enforce_flags = val;
        self
    }
    /// Builds a [ChessGame] with the specified configuration data
    pub fn build(&mut self) -> ChessGame {
        ChessGame {
            rotate_board: self.rotate_board,
            allow_undo: self.allow_undo,
            players: self.players.clone(),
            enforce_flags: self.enforce_flags,
            ..ChessGame::default()
        }
    }
}
